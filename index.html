<!DOCTYPE html>

<!--
  Talk about nodewii by Andrew Brampton

  Using the Google HTML5 slide template
  URL: http://code.google.com/p/html5slides/
-->

<html>
  <head>
    <title>Controlling Node.js with a wiimote</title>

    <meta charset='utf-8'>
    <script src='html5slides/slides.js'></script>

    <script src="js/jquery-1.10.2.min.js"></script>

    <script src="js/raphael-min.js"></script>
    <script src="js/underscore-min.js"></script>
    <script src="js/sequence-diagram-min.js"></script>

    <script>
    $( document ).ready(function() {
      // Make all my diagrams pretty
      $(".diagram").sequenceDiagram({theme: 'hand'});
    });
    </script>
  </head>
  
  <style>
    .slides.template-bramp article.biglogo {
      /*background: white url(images/google-logo.png) 50% 50% no-repeat;*/
    }

    .slides.template-bramp > article:not(.nobackground):not(.biglogo) {
      background: url(bramp-logo-small.png) 710px 625px no-repeat;
      background-color: white;
    }

    .slides.template-bramp h1 {
      margin-top: 150px;
    }

    .slides.template-bramp h1.top {
      margin-top: 0;
    }

    .slides.template-bramp h3 {
      font-size: 45px;
    }
/*
    .slides.template-bramp h3:before {
      content: "// ";
    }
*/
/*
    .slides.template-bramp article {
      width: 1000px;
      height: 700px;
    }
*/

  </style>

  <body style='display: none'>

    <section class='slides layout-regular template-bramp'>

      <article>
        <h1>Node.js + Wiimote = Fun</h1>
        <strong>How to write a custom Node.js addon that interfaces with a Nintendo Wii Remote</strong>
        <p>
          
          <br />
          Andrew Brampton
          <br />
          October 4th, 2013
          <br />
          NationJS
        </p>
      </article>

      <article>
        <h3>whoami</h3>
        <ul>
          <li>Andrew Brampton</li>
          <li>http://bramp.net/ / @TheBramp
          <li><span class="red">Genesys Labs</span></li>
        </ul>
      </article>

      <article>
        <h3>TOC</h3>
        <ul>
          <li>Simple demo
          </li>
          <li>How to write a Node.js Addon
          <ul>
            <li>Build System</li>
            <li>Initialisation</li>
            <li>Calling a function</li>
            <li>Async Work</li>
            <li>if there is time, EventEmitters</li>
          </ul>
          <li>Lessons Learnt</li>
        </ul>
      </article>

      <article>
        <h3>What is a wiimote?</h3>
        <ul>
          <li>
            Used to control the Wii
          </li>
          <li>
            Cool for hacking
            <ul>
              <li>Accelerometer</li>
              <li>Buttons</li>
              <li>Has IR camera</li>
            </ul>
          </li>
          <li>
            Uses bluetooth
          </li>
          <li>
            <strong><a href='http://localhost:8888/'>DEMO!</a></strong>
          </li>
        </ul>
      </article>

      <article>
        <h3>Tech</h3>
            <ul>
              <li><img src="node-logo.png" style="vertical-align:middle"></img></li>
              <li>Socket.io (Websockets) for the realtime feedback</li>
              <li>
                Open source library called libcwiid.
                <ul>
                  <li>Library written in C</li>
                </ul>
              </li>
              <li>and custom nodejs addon, <b>nodewii</b></li>
              <ul>
                <li>Originally by Tim Branyen @tbranyen</li>
                <li>Taken over by me</li>
                <li>problem, uses polling, not callback/event driven</li>
                <li>upgraded to latest Node, libev->libuv, waf->gyp</li>
              </ul>
            </ul>
      </article>

      <article>
        <h3>So how does it work?</h3>
        <p>
          <img class='centered' style='height: 500px' src='diagram-1.svg'>
        </p>
        <!--
        <div class="diagram">
          note right of browser: Socket.io
          browser->node: connect()
          node->wiimote: notifyMe()
          note right of node: some time goes by
          wiimote->node: buttonPress()
          node->node: emit()
          node->browser: emit()
        </div>
        -->
      </article>

      <article>
        <h3>// Client (Browser) code</h3>
        <section>
        <pre>
&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
</pre>
<pre>
1. var socket = io.connect();
2. socket.on( &#39;button&#39;, function( data ) {
3.   console.log(&#39;button was pressed &#39;, data);
4. });
</pre>
        </section>
      </article>

      <article>
        <h3>// Server (Node) code</h3>
        <section>
        <pre>
 1. var wii = require(&#39;nodewii&#39;)
 2.  , express = require(&#39;express&#39;)
 3.  , app     = express()
 4.  , http    = require(&#39;http&#39;)
 5.  , server  = http.createServer(app)
 6.  , io      = require(&#39;socket.io&#39;).listen(server);
 7.
 8. var wiimote = new wii.WiiMote();
 9.
10. wiimote.connect( &#39;00:00:00:00:00:00&#39;, function( err ) {
11.  console.log(&#39;connected&#39;);
12.
13.  wiimote.on( &#39;button&#39;, function( data ) {
14.    io.sockets.emit(&#39;button&#39;, data);
15.  });
16. });
</pre>
        </section>
      </article>


      <article>
        <h2>
          So how do I write a addon?
        </h2>
      </article>

      <article>
        <h3>What you need to learn</h3>
        <ul>
          <li>C++</li>
          <li>v8 - Google's JavaScript engine</li>
          <li>libuv - event library, allows for the non-blocking</li>
          <li>Searching github</li>
        </ul>
        <ul>
          <li>and whatever you want to interface</li>
          <li>libcwiid</li>
        </ul>

      </article>

      <article>
        <h3>Build system</h3>
        <ul>
          <li><b>node-gyp</b> (used to be node-waf)</li>
          <li>like Grunt <img src="grunt-logo.png" style="width: 100px; vertical-align:middle"></img></li>
          <li>Filename: <i>binding.gyp</i></li>
        </ul>
        <section>
        <pre>
{
  "targets": [
    {
      "target_name": "nodewii",
      "sources": [ "src/base.cc", "src/wiimote.cc" ],
      "libraries": [ "-lcwiid", "-lbluetooth" ]
    }
  ]
}
        </pre>
        </section>
      </article>

      <article>
        <h3>Building</h3>
        <pre>$ node-gyp configure</pre>
        <ul>
        <li>creates Makefile (on Linux/Mac) or a .vcxproj file (on Windows)</li>
        </ul>
        <pre>$ node-gyp build</pre>
        <ul>
        <li>Actually builds the project</li>
        <li>Generates <i>build/nodewii.node</i>
        <ul><li><pre>var wii = require('/build/nodewii.node')</pre></li></ul>
        </li>
        </ul>

      </article>


      <article>
        <h3>base.cc</h3>
        <section>
        <pre>
 1. #include &lt;node.h&gt;
 2. #include &lt;v8.h&gt;
 3.
 4. #include &quot;../include/wiimote.h&quot;
 5.
 6. void init(Handle&lt;v8::Object&gt; target) {
 7.  WiiMote::Initialize(target);
 8. }
 9. 
10. NODE_MODULE(nodewii, init);</pre>
        <ul>
          <li>Include v8.h</li>
          <li>All addons need <b>NODE_MODULE</b></li>
        </ul>
        </section>
      </article>

      <article>
        <h3>Initialize(...)</h3>
        <section>
        <pre>
 1. void WiiMote::Initialize (Handle&lt;v8::Object&gt; target) {
 2.   HandleScope scope;
 3.
 4.   Local&lt;FunctionTemplate&gt; t = FunctionTemplate::New(WiiMote::New);
 5.
 6.   constructor = Persistent&lt;FunctionTemplate&gt;::New(t);
 7.   constructor-&gt;SetClassName(String::NewSymbol(&quot;WiiMote&quot;));
 8.
 9.   NODE_SET_PROTOTYPE_METHOD(constructor, &quot;connect&quot;, Connect);
10.   NODE_SET_PROTOTYPE_METHOD(constructor, &quot;disconnect&quot;, Disconnect);
11.
12.   NODE_DEFINE_CONSTANT_NAME(target, &quot;BTN_A&quot;, CWIID_BTN_A);
13.   NODE_DEFINE_CONSTANT_NAME(target, &quot;BTN_B&quot;, CWIID_BTN_B);
14.
15.   target-&gt;Set(String::NewSymbol(&quot;WiiMote&quot;),
16.      constructor-&gt;GetFunction());
17. }</pre>
        </section>
      </article>

      <article>
        <h3>Initialize(...) (if it was JS)</h3>
        <section>
        <pre>
1. Local&lt;FunctionTemplate&gt; t = FunctionTemplate::New(WiiMote::New);
2. 
3. constructor = Persistent&lt;FunctionTemplate&gt;::New(t);
4. constructor-&gt;SetClassName(String::NewSymbol(&quot;WiiMote&quot;));
5. 
6. target-&gt;Set(String::NewSymbol(&quot;WiiMote&quot;),
7.    constructor-&gt;GetFunction());
</pre>
<pre>
 8. module.WiiMote = function WiiMote() {
 9.   // calls C++ WiiMote::New()
10. }
</pre>
        </section>
      </article>


      <article>
        <h3>Initialize(...) (if it was JS)</h3>
        <section>
<pre>
 1. NODE_SET_PROTOTYPE_METHOD(constructor, &quot;connect&quot;, Connect);
 2. NODE_SET_PROTOTYPE_METHOD(constructor, &quot;disconnect&quot;, Disconnect);
 3.
 4. NODE_DEFINE_CONSTANT_NAME(target, &quot;BTN_A&quot;, CWIID_BTN_A);
 5. NODE_DEFINE_CONSTANT_NAME(target, &quot;BTN_B&quot;, CWIID_BTN_B);
</pre>
<pre>
 6. module.WiiMote.connect = Connect;       // Calls C++ Connect(...)
 7. module.WiiMote.disconnect = Disconnect; // Calls C++ Disconnect(...)
 8. 
 9. module.BTN_A = 0x0008; //CWIID_BTN_A;
10. module.BTN_B = 0x0004; //CWIID_BTN_B;
</pre>
        </section>
      </article>


      <article>
        <h3>Connect(...) - Arg validation</h3>
        <section>
<pre>wiimote.connect( '00:00:00:00:00:00', function( err ) {
  console.log('wiimote connected');
});</pre>
<pre>
 1. Handle&lt;Value&gt; WiiMote::Connect(const Arguments&amp; args) {
 2.  HandleScope scope;
 3.
 4.  if(args.Length() == 0 || !args[0]-&gt;IsString()) {
 5.    return ThrowException(Exception::Error(
 6.      String::New(&quot;MAC address is required and must be a String.&quot;))
 7.    );
 8.  }
 9.  if(args.Length() == 1 || !args[1]-&gt;IsFunction()) {
10.    return ThrowException(Exception::Error(
11.      String::New(&quot;Callback is required and must be a Function.&quot;))
12.    );
14.  }
15.  String::Utf8Value mac(args[0]);
16.  Local&lt;Function&gt; callback = Local&lt;Function&gt;::Cast(args[1]);
</pre>
        </section>
      </article>

<!--
      <article>
        <h3>WiiMote::Connect - Reference Counting</h3>
        <section>
<pre>
  WiiMote* wiimote = ObjectWrap::Unwrap&lt;WiiMote&gt;(args.This());

  connect_request* ar = new connect_request();
  ar-&gt;wiimote = wiimote;
  str2ba(*mac, &amp;ar-&gt;mac);

  ar-&gt;callback = Persistent&lt;Function&gt;::New(callback);

  wiimote-&gt;Ref();
</pre>
        </section>
        <img src="hipster-hacker.png"></img>
      </article>
-->

      <article>
        <h3>Connect(...) - Do some async work</h3>
        <section>
<pre>
 1.   connect_request* ar = new connect_request();
 2.   ar-&gt;wiimote = wiimote;
 3.   str2ba(*mac, &amp;ar-&gt;mac);
 4. 
 5.   uv_work_t* req = new uv_work_t;
 6.   req-&gt;data = ar;
 7. 
 8.   int r = uv_queue_work(uv_default_loop(), req,
 9.      UV_Connect, UV_AfterConnect);
10.   if (r != 0) {
11.      // Error handling
12.   }
13.
14.   return Undefined();
15. }
</pre>
        </section>
      </article>

      <article>
        <h3>UV_Connect(...) - Do some blocking work</h3>
        <section>
<pre>
 1. void WiiMote::UV_Connect(uv_work_t* req) {
 2.   connect_request* ar = static_cast&lt;connect_request* &gt;(req-&gt;data);
 3. 
 4.    ar-&gt;wiimote = cwiid_open(&amp;ar-&gt;mac, CWIID_FLAG_MESG_IFC)
 5.    if(ar-&gt;wiimote) {
 6.      ar-&gt;err = 0;
 7.    } else {
 8.      ar-&gt;err = -1;
 9.    }
10. }
</pre>
        </section>
      </article>

    <article>
        <h3>UV_AfterConnect(...) - Do some after work</h3>
        <section>
<pre>
 1. void WiiMote::UV_AfterConnect(uv_work_t* req, int status) {
 2.   HandleScope scope;
 3. 
 4.   connect_request* ar = static_cast&lt;connect_request* &gt;(req-&gt;data);
 5. 
 6.   WiiMote * wiimote = ar-&gt;wiimote;
 7. 
 8.   if (ar-&gt;err == 0) {
 9.     // Setup the callback to receive events
10.     cwiid_set_data(wiimote-&gt;wiimote, wiimote);
11.     cwiid_set_mesg_callback(wiimote-&gt;wiimote,
12.        WiiMote::HandleMessages);
13.   }
14. }
</pre>
        </section>
      </article>


    <article>
        <h3>UV_AfterConnect(..) - Do some callback work</h3>
        <section>
<pre>
 1.  TryCatch try_catch;
 2.
 3.  Local&lt;Value&gt; argv[1] = { Integer::New(ar-&gt;err) };
 4.  ar-&gt;callback-&gt;Call(Context::GetCurrent()-&gt;Global(), 1, argv);
 5.
 6.  if(try_catch.HasCaught())
 7.    FatalException(try_catch);
 8.
 9.  ar-&gt;callback.Dispose();
10.  delete ar;
</pre>
        </section>
      </article>

      <article>
        <h3>So what is going on here?</h3>
        <p>
          <img class='centered' style='height: 500px' src='diagram-2.svg'>
        </p>
        <!--
        <div class="diagram">
note over JavaScript, Addon: On the Main V8 Thread
JavaScript->Addon: Connect(...)
Addon->Addon: uv_queue_work(...)
Addon- ->JavaScript:
note over JavaScript, Addon: Other stuff continues to run
Worker->Worker: UV_Connect(...)
Worker- ->Addon: 
Addon->Addon: UV_AfterConnect(...)
Addon- ->JavaScript: Callback
        </div>
        -->
      </article>

    <article>
        <h3>HandleMessages(..) - libcwiid callback</h3>
        <section>
<pre>
1. void WiiMote::HandleMessages(cwiid_wiimote_t *wiimote, int len, union cwiid_mesg mesgs[], struct timespec *timestamp) {
2.   ...
3.   // We need to pass this over to the nodejs thread, so it can create V8 objects
4.   uv_work_t* uv = new uv_work_t;
5.   uv->data = req;
6.   int r = uv_queue_work(uv_default_loop(), uv, 
7.      UV_NOP, WiiMote::HandleMessagesAfter);
</pre>
        </section>
      </article>

      <article>
        <h3>HandleButtonMessage(..)</h3>
        <section>
<pre>
1. void WiiMote::HandleButtonMessage(struct timespec *ts, cwiid_btn_mesg * msg) {
2.   HandleScope scope;
3. 
4.   Local<Integer> btn = Integer::New(msg->buttons);
5. 
6.   Local<Value> argv[2] = { String::New("button"), btn };
7.   MakeCallback(self, "emit", ARRAY_SIZE(argv), argv);
8. }
</pre>
<pre>
1.  this.emit('button', CWIID_BTN_A);
</pre>
        </section>
      </article>

      <article>
        <h3>So what is going on here?</h3>
        <p>
          <img class='centered' style='height: 500px' src='diagram-3.svg'>
        </p>
        <!--
participant JavaScript
participant Addon
participant Worker
note over libcwiid: On the libcwiid Thread
note over JavaScript, Addon: On the Main V8 Thread
libcwiid->libcwiid: HandleMessages(..)
libcwiid->libcwiid: uv_queue_work(...)
libcwiid- ->Addon:
Worker->Worker: UV_NOP(...)
Worker- ->Addon: 
Addon->Addon: HandleMessagesAfter(...)
Addon- ->JavaScript: emit(...)
        -->
      </article>

      <article>
        <h2>
          Leasons learnt
        </h2>
      </article>

      <article>
        <h3>Don't do any V8 on worker threads</h3>
        <p>
          <img class='centered' style='height: 500px' src='bad-flow.svg'>
        </p>
<!--
        <div class="diagram">
note over JavaScript, Addon: On the Main V8 Thread
JavaScript->Addon: Connect(...)
Addon->Addon: uv_queue_work(...)
Addon- ->JavaScript:
note over JavaScript, Addon: Other stuff continues to run
Worker->Worker: UV_Connect(...)
Worker- ->JavaScript: Callback
        </div>
-->
      </article>

      <article>
        <h3>V8 memory model is tricky</h3>
        <ul>
          <li>Easy to hold memory too long</li>
          <li>Easy for memory to be garbage collected</li>
        </ul>
        <pre>
ar-&gt;callback = Persistent&lt;Function&gt;::New(callback);
wiimote-&gt;Ref();
wiimote-&gt;UnRef();</pre>
        <ul>
          <li>Most Addons out there leak memory, or use it incorrectly</li>
          <ul>
            <li>node-mongodb-native</li>
            <li>node-mysql</li>
          </ul>
        </ul>
      </article>

      <article>
        <h3>V8 memory model is tricky</h3>
        <br />
        <img src="hipster-hacker.png"></img>
        <ul>
          <li><a href="http://valgrind.org/">Valgrind</a>, <a href="http://clang.llvm.org/">Clang</a>, and other tools really useful!</li>
        </ul>
      </article>

      <article>
        <h3>Node is constantly changing!</h3>

        <ul>
          <li>In the last year I've been forced to change</li>
          <ul>
            <li>EventEmitter</li>
            <ul>
              <li>emit('something')</li>
              <li>on('something', function () {...})</li>
            </ul>
            <li>libev -> libuv</li>
            <ul>
              <li>
                The internal threading library used
              </li>
            </ul>
            <li>waf->gyp</li>
            <ul>
              <li>
                Build system
              </li>
            </ul>
          </ul>
        </ul>
      </article>

      <article class="fill">
        <h3>Thanks - Questions?</h3>
        <h4>
          Andrew Brampton - <a href="http://bramp.net/">http://bramp.net</a><br />
          Get my contact by texting "<span class="blue">bramp</span>" to <span class="blue">99222</span>
        </h4>
        <ul>
          <li>nodewii - <a href="https://github.com/bramp/nodewii">github.com/bramp/nodewii</a></li>
          <li>libcwiid - <a href="http://abstrakraft.org/cwiid/wiki/libcwiid">abstrakraft.org/cwiid/wiki/libcwiid</a></li>
          <li>Node.js Addons - <a href="http://nodejs.org/api/addons.html">nodejs.org/api/addons.html</a></li>
          <li>v8 Embedder's Guide - <a href="http://developers.google.com/v8/embed">developers.google.com/v8/embed</a></li>
        </ul>

        <br />
        <h3>
          <span class="red">Genesys Labs is hiring!</span><br />
        </h3>
        </center>
      </article>

    </section>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-36551491-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </body>
</html>
